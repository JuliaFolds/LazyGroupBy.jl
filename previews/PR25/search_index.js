var documenterSearchIndex = {"docs":
[{"location":"#LazyGroupBy.jl","page":"Home","title":"LazyGroupBy.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LazyGroupBy]\nFilter = LazyGroupBy._is_public","category":"page"},{"location":"#LazyGroupBy.LazyGroupBy","page":"Home","title":"LazyGroupBy.LazyGroupBy","text":"LazyGroupBy: lazy, parallelizable and composable group-by operations\n\n(Image: Dev) (Image: GitHub Actions)\n\nLazyGroupBy.jl exports a single API grouped.  It can be used to run group-by operation using the dot-call syntax:\n\nreducer.(..., grouped(key, collection), ...)\n\nwhere reducer runs on each group (thus, grouped(key, collection) can be considered a as a key-value pairs with Dictionaries.jl-like broadcasting rule).  Roughly speaking, grouped(key, collection) is equivalent to Dict(k_1 => [v_11, v_12, ...], k_2 => [v_21, v_22, ...], ...) where k_i is an output of value of key(v_ij) for v_ij in collection and each call of reducer is evaluated with a group \"vector\" [v_i1, v_i2, ...].\n\nFor example:\n\njulia> using LazyGroupBy\n\njulia> collect.(grouped(isodd, 1:7))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [2, 4, 6]\n  true  => [1, 3, 5, 7]\n\njulia> length.(grouped(isodd, 1:7))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 4\n\njulia> keys.(grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [1, 7, 9]\n  true  => [2, 3, 4, 5, 6, 8, 10]\n\njulia> foldl.(tuple, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Any,…} with 2 entries:\n  false => ((0, 4), 0)\n  true  => ((((((7, 3), 1), 5), 9), 3), 5)\n\njulia> foldl.(tuple, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]); init = -1)\nTransducers.GroupByViewDict{Bool,Tuple{Any,Int64},…} with 2 entries:\n  false => (((-1, 0), 4), 0)\n  true  => (((((((-1, 7), 3), 1), 5), 9), 3), 5)\n\njulia> extrema_rf((min1, max1), (min2, max2)) = (min(min1, min2), max(max1, max2));\n\njulia> mapfoldl.(x -> (x, x), extrema_rf, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Tuple{Int64,Int64},…} with 2 entries:\n  false => (0, 4)\n  true  => (1, 9)\n\nFollowing generic and standard reducers are supported:\n\ncollect.(op, grouped(...)) → DICT{Key,Vector{...}}\nview.(grouped(_, array)) → DICT{Key,SubArray}\nmap.(f, grouped(...))\nlength.(op, grouped(...)) → DICT{Key,Int}\ncount.([f,] op, grouped(...)) → DICT{Key,Int}\nsum.([f,] op, grouped(...)) → DICT{Key,Number}\nprod.([f,] op, grouped(...)) → DICT{Key,Number}\nany.(f, op, grouped(...)) → DICT{Key,Bool}\nall.(f, op, grouped(...)) → DICT{Key,Bool}\nminimum.([f,] op, grouped(...))\nmaximum.([f,] op, grouped(...))\nextrema.([f,] op, grouped(...))\nkeys.(op, grouped(_, collection)) → DICT{Key,Vector{keytype(collection)}}\npairs.(op, grouped(_, collection)) → DICT{Key,DICT{keytype(collection),valtype(collection)}}\nfindfirst.(f, grouped(_, array)) → DICT{Key,keytype(collection)}\nfindlast.(f, grouped(_, array)) → DICT{Key,keytype(collection)}\nfindall.(f, grouped(_, array)) → DICT{Key,Vector{keytype(collection)}}\nfoldl.(op, grouped(...); [init])\nmapfoldl.(f, op, grouped(...); [init])\n\nwhere DICT{K,V} above is a short-hand for AbstractDict{<:K,<:V} and Key is the type of the values returned from key function passed to grouped.\n\nFor more complex tasks, Transducers.jl and OnlineStats.jl can also be used:\n\nfoldl.(op, xf, grouped(...); [init])\nfoldxl.(op, [xf,] grouped(...); [init])\nfoldxt.(op, [xf,] grouped(...); [init]) (multi-threaded)\nfoldxd.(op, [xf,] grouped(...); [init]) (distributed)\ncollect.(xf, grouped(...))\ntcollect.(xf, grouped(...)) (multi-threaded version of collect)\ndcollect.(xf, grouped(...)) (distributed version of collect)\n\nwhere xf::Transducer is initiated for each group individually and op is either a two-argument function or an OnlineStat object (e.g., OnlineStats.Mean).\n\nCaveats\n\nThe dot-call syntax is used for defining the \"domain-specific language\" (DSL) and it is different from the standard semantics of broadcasting on arrays.  In particular, reducer.(..., grouped(key, collection), ...) may not actually call reducer.  Rather, it is pattern-matched and dispatched to an alternative definition based on Transducers.jl.\n\nImplementation\n\nLazyGroupBy.jl is implemented as a direct transformation to foldl/foldxt/foldxd and GroupBy from Transducer.jl.  Consider\n\nfoldl.(rf, xf, grouped(key, collection); init = init)\n\nThis is simply translated to\n\nfoldl(right, GroupBy(key, xf, rf, init), collection)\n\nOther reducers like sum and collect are implemented in terms of above transformation.\n\n\n\n\n\n","category":"module"},{"location":"#Base.all","page":"Home","title":"Base.all","text":"all.(f, grouped(key, array))\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 3];\n\njulia> gs = all.(<(1), grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Bool,…} with 2 entries:\n  false => true\n  true  => false\n\n\n\n\n\n","category":"function"},{"location":"#Base.any","page":"Home","title":"Base.any","text":"any.(f, grouped(key, array))\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 3];\n\njulia> gs = any.(>(5), grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Bool,…} with 2 entries:\n  false => false\n  true  => true\n\n\n\n\n\n","category":"function"},{"location":"#Base.collect","page":"Home","title":"Base.collect","text":"collect.([xf,] grouped(key, collection))\n\nCollect each group as a Vector.\n\nThe first optional argument xf is a transducer.\n\nExample\n\njulia> using LazyGroupBy\n\njulia> collect.(grouped(isodd, [0, 7, 3]))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [0]\n  true  => [7, 3]\n\n\n\n\n\n","category":"function"},{"location":"#Base.count","page":"Home","title":"Base.count","text":"count.([f,] grouped(key, collection))\n\nCount number of items f is evaluated to true in each group.\n\nExample\n\njulia> using LazyGroupBy\n\njulia> count.(<(5), grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 3\n\n\n\n\n\n","category":"function"},{"location":"#Base.extrema","page":"Home","title":"Base.extrema","text":"extrema.([f,] grouped(key, collection); [init])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 2, 3];\n\njulia> extrema.(grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Tuple{Int64,Int64},…} with 2 entries:\n  false => (0, 2)\n  true  => (3, 7)\n\n\n\n\n\n","category":"function"},{"location":"#Base.findall","page":"Home","title":"Base.findall","text":"findall.(f, grouped(key, array))\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 2, 3];\n\njulia> gs = findall.(>(1), grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [3]\n  true  => [2, 4]\n\njulia> xs[gs[false]]\n1-element Array{Int64,1}:\n 2\n\njulia> xs[gs[true]]\n2-element Array{Int64,1}:\n 7\n 3\n\n\n\n\n\n","category":"function"},{"location":"#Base.findfirst","page":"Home","title":"Base.findfirst","text":"findfirst.(f, grouped(key, array))\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 2, 3];\n\njulia> gs = findfirst.(>(1), grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 2\n\njulia> xs[gs[false]]\n2\n\njulia> xs[gs[true]]\n7\n\n\n\n\n\n","category":"function"},{"location":"#Base.findlast","page":"Home","title":"Base.findlast","text":"findlast.(f, grouped(key, array))\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 2, 3];\n\njulia> gs = findlast.(<(5), grouped(isodd, xs))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 4\n\njulia> xs[gs[false]]\n2\n\njulia> xs[gs[true]]\n3\n\n\n\n\n\n","category":"function"},{"location":"#Base.foldl","page":"Home","title":"Base.foldl","text":"foldl.(op, [xf,] grouped(key, collection); [init])\nfoldl.(os::OnlineStat, [xf,] grouped(key, collection); [init])\n\nThe first argument is either a reducing step function or an OnlineStat.  The second optional argument xf is a transducer.\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> foldl.(tuple, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Any,…} with 2 entries:\n  false => ((0, 4), 0)\n  true  => ((((((7, 3), 1), 5), 9), 3), 5)\n\njulia> using OnlineStats\n\njulia> foldl.(Ref(Mean()), grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Mean{Float64,EqualWeight},…} with 2 entries:\n  false => Mean: n=3 | value=1.33333\n  true  => Mean: n=7 | value=4.71429\n\n\n\n\n\n","category":"function"},{"location":"#Base.keys","page":"Home","title":"Base.keys","text":"keys.(grouped(key, indexable))\n\nReturn a dictionary whose value is a vector of keys to the indexable input collection.\n\nExample\n\njulia> using LazyGroupBy\n\njulia> keys.(grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [1, 7, 9]\n  true  => [2, 3, 4, 5, 6, 8, 10]\n\njulia> keys.(grouped(isodd, Dict(zip('a':'e', 1:5))))\nTransducers.GroupByViewDict{Bool,Array{Char,1},…} with 2 entries:\n  false => ['d', 'b']\n  true  => ['a', 'c', 'e']\n\n\n\n\n\n","category":"function"},{"location":"#Base.length","page":"Home","title":"Base.length","text":"length.(grouped(key, collection))\n\nCount number of items in each group.  This is defined as count.(_ -> true, grouped(key, collection)) rather than materializing each group vector.\n\nExample\n\njulia> using LazyGroupBy\n\njulia> length.(grouped(isodd, 1:7))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 4\n\n\n\n\n\n","category":"function"},{"location":"#Base.map","page":"Home","title":"Base.map","text":"map.(f, grouped(key, collection))\n\nLike collect.(grouped(key, collection)), but process each item with f.\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> map.(string, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Array{String,1},…} with 2 entries:\n  false => [\"0\", \"4\", \"0\"]\n  true  => [\"7\", \"3\", \"1\", \"5\", \"9\", \"3\", \"5\"]\n\n\n\n\n\n","category":"function"},{"location":"#Base.mapfoldl","page":"Home","title":"Base.mapfoldl","text":"mapfoldl.(f, op, grouped(key, collection); [init])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> extrema_rf((min1, max1), (min2, max2)) = (min(min1, min2), max(max1, max2));\n\njulia> mapfoldl.(x -> (x, x), extrema_rf, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Tuple{Int64,Int64},…} with 2 entries:\n  false => (0, 4)\n  true  => (1, 9)\n\n\n\n\n\n","category":"function"},{"location":"#Base.maximum","page":"Home","title":"Base.maximum","text":"maximum.([f,] grouped(key, collection); [init])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> maximum.(grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 4\n  true  => 9\n\n\n\n\n\n","category":"function"},{"location":"#Base.minimum","page":"Home","title":"Base.minimum","text":"minimum.([f,] grouped(key, collection); [init])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> minimum.(grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 0\n  true  => 1\n\n\n\n\n\n","category":"function"},{"location":"#Base.pairs","page":"Home","title":"Base.pairs","text":"pairs.(grouped(key, indexable))\n\nReturn a dictionary whose value is a vector of keys to the indexable input collection.\n\nExample\n\njulia> using LazyGroupBy\n\njulia> pairs.(grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Dict{Int64,Int64},…} with 2 entries:\n  false => Dict(7=>4,9=>0,1=>0)\n  true  => Dict(4=>1,10=>5,2=>7,3=>3,5=>5,8=>3,6=>9)\n\njulia> pairs.(grouped(isodd, Dict(zip('a':'e', 1:5))))\nTransducers.GroupByViewDict{Bool,Dict{Char,Int64},…} with 2 entries:\n  false => Dict('d'=>4,'b'=>2)\n  true  => Dict('a'=>1,'c'=>3,'e'=>5)\n\n\n\n\n\n","category":"function"},{"location":"#Base.prod","page":"Home","title":"Base.prod","text":"prod.([f,] grouped(key, collection); [prod])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> prod.(grouped(isodd, [7, 3, 1, 5, 9, 4, 3, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 4\n  true  => 14175\n\n\n\n\n\n","category":"function"},{"location":"#Base.sum","page":"Home","title":"Base.sum","text":"sum.([f,] grouped(key, collection); [init])\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> sum.(grouped(isodd, [7, 3, 1, 5, 9, 4, 3, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 4\n  true  => 33\n\n\n\n\n\n","category":"function"},{"location":"#Base.view","page":"Home","title":"Base.view","text":"view.(grouped(key, array))\n\nLike collect.(grouped(key, array)), but return a mutable view to the input array.\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> xs = [0, 7, 3];\n\njulia> gs = view.(grouped(isodd, xs))\nDict{Bool,SubArray{Int64,1,Array{Int64,1},Tuple{Array{Int64,1}},false}} with 2 entries:\n  false => [0]\n  true  => [7, 3]\n\njulia> gs[false][end] = 111;\n\njulia> xs\n3-element Array{Int64,1}:\n 111\n   7\n   3\n\n\n\n\n\n","category":"function"},{"location":"#LazyGroupBy.grouped-Tuple{Any,Any}","page":"Home","title":"LazyGroupBy.grouped","text":"grouped(key, collection)\n\nCreate a lazy associative (dict-like) object grouped by a function key.  Actual per-group reduction can be initiated by the dot-call (broadcasting) of the \"reducers\" like foldl and reduce.\n\nExamples\n\njulia> using LazyGroupBy\n\njulia> length.(grouped(isodd, 1:7))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 3\n  true  => 4\n\n\n\n\n\n","category":"method"},{"location":"#Statistics.mean","page":"Home","title":"Statistics.mean","text":"mean.([f,] grouped(key, collection))\n\nCompute mean of each group.\n\nExample\n\njulia> using LazyGroupBy, Statistics\n\njulia> mean.(grouped(isodd, 1:7))\nDict{Bool,Float64} with 2 entries:\n  false => 4.0\n  true  => 4.0\n\n\n\n\n\n","category":"function"},{"location":"#Statistics.std","page":"Home","title":"Statistics.std","text":"std.([f,] grouped(key, collection))\n\nCompute standard deviation of each group.\n\nExample\n\njulia> using LazyGroupBy, Statistics\n\njulia> std.(grouped(isodd, 1:10))\nDict{Bool,Float64} with 2 entries:\n  false => 3.16228\n  true  => 3.16228\n\n\n\n\n\n","category":"function"},{"location":"#Statistics.var","page":"Home","title":"Statistics.var","text":"var.([f,] grouped(key, collection))\n\nCompute variance of each group.\n\nExample\n\njulia> using LazyGroupBy, Statistics\n\njulia> var.(grouped(isodd, 1:10))\nDict{Bool,Float64} with 2 entries:\n  false => 10.0\n  true  => 10.0\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Modules = [LazyGroupBy]\nFilter = !LazyGroupBy._is_public","category":"page"},{"location":"internals/#Transducers.dcollect","page":"Internals","title":"Transducers.dcollect","text":"dcollect.([xf,] grouped(key, collection))\n\nCollect each group as a Vector using Distributed.jl.\n\nThe first optional argument xf is a transducer.\n\nExample\n\njulia> using LazyGroupBy\n       using Transducers\n\njulia> dcollect.(grouped(isodd, [0, 7, 3]))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [0]\n  true  => [7, 3]\n\n\n\n\n\n","category":"function"},{"location":"internals/#Transducers.foldxd","page":"Internals","title":"Transducers.foldxd","text":"foldxd.(op, [xf,] grouped(key, collection); [init])\nfoldxd.(os::OnlineStat, [xf,] grouped(key, collection); [init])\n\nThe first argument is either a reducing step function or an OnlineStat.  The second optional argument xf is a transducer.\n\nExamples\n\njulia> using LazyGroupBy\n       using Transducers\n\njulia> foldxd.(+, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 4\n  true  => 33\n\n\n\n\n\n","category":"function"},{"location":"internals/#Transducers.foldxt","page":"Internals","title":"Transducers.foldxt","text":"foldxt.(op, [xf,] grouped(key, collection); [init])\nfoldxt.(os::OnlineStat, [xf,] grouped(key, collection); [init])\n\nThe first argument is either a reducing step function or an OnlineStat.  The second optional argument xf is a transducer.\n\nExamples\n\njulia> using LazyGroupBy, Transducers\n\njulia> foldxt.(max, grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Int64,…} with 2 entries:\n  false => 4\n  true  => 9\n\njulia> using OnlineStats\n\njulia> foldxt.(Ref(Mean()), grouped(isodd, [0, 7, 3, 1, 5, 9, 4, 3, 0, 5]))\nTransducers.GroupByViewDict{Bool,Mean{Float64,EqualWeight},…} with 2 entries:\n  false => Mean: n=3 | value=1.33333\n  true  => Mean: n=7 | value=4.71429\n\nAn example for calculating the minimum, maximum, and number of each group in one go:\n\njulia> table = ((k = gcd(v, 42), v = v) for v in 1:100);\n\njulia> collect(Iterators.take(table, 5))  # preview\n5-element Array{NamedTuple{(:k, :v),Tuple{Int64,Int64}},1}:\n (k = 1, v = 1)\n (k = 2, v = 2)\n (k = 3, v = 3)\n (k = 2, v = 4)\n (k = 1, v = 5)\n\njulia> counter = reducingfunction(Map(_ -> 1), +);\n\njulia> foldxt.(TeeRF(min, max, counter), Map(x -> x.v), grouped(x -> x.k, table))\nTransducers.GroupByViewDict{Int64,Tuple{Int64,Int64,Int64},…} with 8 entries:\n  7  => (7, 91, 5)\n  14 => (14, 98, 5)\n  42 => (42, 84, 2)\n  2  => (2, 100, 29)\n  3  => (3, 99, 15)\n  21 => (21, 63, 2)\n  6  => (6, 96, 14)\n  1  => (1, 97, 28)\n\n\n\n\n\n","category":"function"},{"location":"internals/#Transducers.tcollect","page":"Internals","title":"Transducers.tcollect","text":"tcollect.([xf,] grouped(key, collection))\n\nCollect each group as a Vector using multiple threads. See also collect.(grouped(key, collection)).\n\nThe first optional argument xf is a transducer.\n\nExample\n\njulia> using LazyGroupBy\n       using Transducers\n\njulia> tcollect.(grouped(isodd, [0, 7, 3]))\nTransducers.GroupByViewDict{Bool,Array{Int64,1},…} with 2 entries:\n  false => [0]\n  true  => [7, 3]\n\n\n\n\n\n","category":"function"}]
}
